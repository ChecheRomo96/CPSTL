#ifndef CPSTL_EXCEPTION_H
#define CPSTL_EXCEPTION_H

    #include <CPSTL_BuildSettings.h>

    namespace cpstd{

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // cpstd::exception

        #ifdef CPSTL_USING_STL
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        //! @ingroup CPSTL_EXCEPTION
        //! @class cpstd::exception cpstd_Exceptions.h "src/cpstd_Exceptions.h"
        //! @brief cpstd exception class.
        //! 
        //! Provides consistent interface to handle errors through the throw expression.\n
        //! All exceptions generated by the cpstd library inherit from cpstd::exception.\n
        //! This class belongs to the group: @link CPSTL_EXCEPTION Cross Platform Vector Exceptions@endlink
        
            class exception : public std::exception {
            public:
                exception() noexcept: std::exception(){}
                exception (const exception&) noexcept{}
                exception& operator= (const exception&) noexcept{ return (*this); }

                const char* what() const throw() {
                    return "cpstd::exception";
                }
            };
        //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        #else
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        //! @ingroup CPSTL_EXCEPTION
        //! @class cpstd::exception cpstd_Exceptions.h "src/cpstd_Exceptions.h"
        //! @brief cpstd exception class.
        //! 
        //! Provides consistent interface to handle errors through the throw expression.\n
        //! All exceptions generated by the cpstd library inherit from cpstd::exception.\n
        //! This class belongs to the group: @link CPSTL_EXCEPTION Cross Platform Vector Exceptions@endlink

            class exception {
            public:
                exception () noexcept{}
                exception (const exception&) noexcept{}
                exception& operator= (const exception&) noexcept{ return (*this); }
                virtual ~exception(){};
                
                virtual const char* what() const noexcept{
                    return "cpstd::exception";
                }
            };
        //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        #endif

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Directly Derived Types
    
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        // bad_alloc

            /////////////////////////////////////////////////////////////////////////////////////////////////////
            //! @ingroup CPSTL_EXCEPTION
            //! @class cpstd::bad_alloc cpstd_Exceptions.h "src/cpstd_Exceptions.h"
            //! @brief  Exception thrown on failure allocating memory.
            //! 
            //! All exceptions generated by the cpstd library inherit from cpstd::exception.\n
            //! This class belongs to @link CPSTL_EXCEPTION Cross Platform Vector Exceptions@endlink
            
            
                #ifdef CPSTL_USING_STL
                    using bad_alloc = std::bad_alloc;
                #else
                    class bad_alloc : public cpstd::exception {
                    public:
                        bad_alloc(): cpstd::exception(){}
                        bad_alloc(const bad_alloc& other) noexcept: cpstd::exception(){}

                        const char* what() const throw() {
                            return "cpstd::bad_alloc";
                        }
                    };                
                #endif
            //
            /////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        // logic_error
            
            #ifndef CPSTL_USING_STL
                namespace {
                    const char logic_error_str[] = "cpstd::logic_error";
                }
            #endif

            /////////////////////////////////////////////////////////////////////////////////////////////////////////
            //! @ingroup CPSTL_EXCEPTION
            //! @class cpstd::logic_error cpstd_Exceptions.h "src/cpstd_Exceptions.h"
            //! @brief Logic error exception.
            //! 
            //! This class defines the type of objects thrown as exceptions to report errors in the internal logical of the program, such as violation of logical preconditions or class invariants.\n
            //! These errors are presumably detectable before the program executes.\n
            //! This class exceptions inherits from from cpstd::exception.\n
            //! This class belongs to the group: @link CPSTL_EXCEPTION Cross Platform Vector Exceptions@endlink
                

                #ifdef CPSTL_USING_STL
                    using logic_error = std::logic_error;
                #else
                    class logic_error : public cpstd::exception {
                    private:
                        std::string _M_msg;
                    public:
                        explicit logic_error() : exception(), _M_msg(logic_error_str){}
                        explicit logic_error(const std::string& __arg) : exception(), _M_msg(logic_error_str){ _M_msg += " ->" + __arg; }
                        explicit logic_error(const char* message) : exception(), _M_msg(logic_error_str){ _M_msg += " ->" + std::string(message); }

                        ~logic_error() throw() { }

                        explicit logic_error(const logic_error& other) noexcept{
                            if(this != &other){
                                _M_msg = other.what();
                            }
                        }

                        const char* what() const throw(){ 
                            return _M_msg.c_str(); 
                        }
                    };       
                #endif

            //
            /////////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        // cpstd::runtime_error
        
            #ifndef CPSTL_USING_STL
                namespace {
                    const char runtime_error_str[] = "cpstd::runtime_error";
                }
            #endif

            /////////////////////////////////////////////////////////////////////////////////////////////////////////
            //! @ingroup CPSTL_EXCEPTION
            //! @class cpstd::runtime_error cpstd_Exceptions.h "src/cpstd_Exceptions.h"
            //! @brief Logic error exception.
            //! 
            //! This class defines the type of objects thrown as exceptions to report errors in the internal logical of the program, such as violation of logical preconditions or class invariants.\n
            //! These errors are presumably detectable before the program executes.\n
            //! This class exceptions inherits from from cpstd::exception.\n
            //! This class belongs to the group: @link CPSTL_EXCEPTION Cross Platform Vector Exceptions@endlink
            //
                #ifdef CPSTL_USING_STL
                    using runtime_error = std::runtime_error;
                #else
                    class runtime_error : public cpstd::exception {
                    private:
                        std::string _M_msg;
                    public:
                        explicit runtime_error() : exception(), _M_msg(runtime_error_str){}
                        explicit runtime_error(const std::string& __arg) : exception(), _M_msg(runtime_error_str){ _M_msg += " ->" + __arg; }
                        explicit runtime_error(const char* message) : exception(), _M_msg(runtime_error_str){ _M_msg += " ->" + std::string(message); }

                        ~runtime_error() throw() { }

                        explicit runtime_error(const runtime_error& other) noexcept{
                            if(this != &other){
                                _M_msg = other.what();
                            }
                        }

                        const char* what() const throw(){ 
                            return _M_msg.c_str(); 
                        }
                    }; 
                #endif
            //
            /////////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Indirectly (Through logic_error)
    
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        // cpstd::out_of_range

            /////////////////////////////////////////////////////////////////////////////////////////////////////////
            //! @ingroup CPSTL_EXCEPTION
            //! @class cpstd::out_of_range cpstd_Exceptions.h "src/cpstd_Exceptions.h"
            //! @brief  Out-of-range exception.
            //!
            //! ###Test
            //! All exceptions generated by the cpstd library inherit from cpstd::exception.\n
            //! This class belongs to @link CPSTL_EXCEPTION Cross Platform Vector Exceptions@endlink

                #ifdef CPSTL_USING_STL
                    using out_of_range = std::out_of_range;
                #else
                    class out_of_range : public cpstd::logic_error {
                    public:
                        out_of_range() : cpstd::logic_error(what()){}
                        out_of_range(const std::string& what_arg) : cpstd::logic_error(what_arg){}
                        out_of_range(const char* what_arg) : cpstd::logic_error(what_arg){}
                        out_of_range(const out_of_range& other) noexcept: cpstd::logic_error(other){}

                        const char* what() const throw() {
                            return "cpstd::out_of_range";
                        }
                    };
                #endif
            //
            /////////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        // cpstd::length_error

            /////////////////////////////////////////////////////////////////////////////////////////////////////////
            //! @ingroup CPSTL_EXCEPTION
            //! @class cpstd::length_error cpstd_Exceptions.h "src/cpstd_Exceptions.h"
            //! @brief  exception class to report attempts to exceed maximum allowed size.
            //! 
            //! All exceptions generated by the cpstd library inherit from cpstd::exception.\n
            //! This class belongs to @link CPSTL_EXCEPTION Cross Platform Vector Exceptions@endlink
            
                #ifdef CPSTL_USING_STL
                    using length_error = std::length_error;
                #else
                    class length_error : public cpstd::logic_error {
                    public:
                        length_error() : cpstd::logic_error(what()){}
                        length_error(const std::string& what_arg) : cpstd::logic_error(what_arg){}
                        length_error(const char* what_arg) : cpstd::logic_error(what_arg){}
                        length_error(const logic_error& other) noexcept: cpstd::logic_error(other){}

                        const char* what() const throw() {
                            return "cpstd::length_error";
                        }
                    };
                #endif
            //
            /////////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    }
        
#endif//CPSTL_EXCEPTION_H